#!/usr/bin/env python3
"""
Pentest Light — Recon prudent amb logging (verbose) i escaneig de ports connect (concurrent).
Ús responsable: només executar contra targets amb autorització.
"""
import argparse
import socket
import sys
import io
import re
import json
import threading
from queue import Queue
from datetime import datetime
from urllib.parse import urlparse
from urllib.request import Request, urlopen
from urllib.error import URLError, HTTPError

# Optional dnspython
try:
    import dns.resolver  # type: ignore
    HAVE_DNSPY = True
except Exception:
    HAVE_DNSPY = False

C_GREEN = '\033[92m'
C_YELLOW = '\033[93m'
C_RED = '\033[91m'
C_END = '\033[0m'

def cprint(tag, msg, color=C_GREEN):
    print(f"{color}[{tag}]{C_END} {msg}")

def banner():
    print(f"{C_GREEN}[*]{C_END} Pentest Light — Real-world Passive Recon (safe)")

def normalize_target(raw_url: str):
    if not re.match(r'^[a-zA-Z][a-zA-Z0-9+.-]*://', raw_url):
        raw_url = 'http://' + raw_url
    p = urlparse(raw_url)
    host = p.hostname or raw_url
    scheme = p.scheme or 'http'
    port = p.port
    if port is None:
        port = 443 if scheme == 'https' else 80
    root = host[4:] if host.startswith('www.') else host
    return {"raw": raw_url.rstrip('/'), "scheme": scheme, "host": host, "port": port, "root": root}

def whois_query(server: str, query: str, timeout=10) -> str:
    data = b""
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(timeout)
    try:
        s.connect((server, 43))
        s.sendall((query + "\r\n").encode("utf-8", errors="ignore"))
        while True:
            chunk = s.recv(4096)
            if not chunk:
                break
            data += chunk
    finally:
        s.close()
    return data.decode("utf-8", errors="ignore")

def whois_lookup(domain: str) -> str:
    parts = domain.strip().split(".")
    if len(parts) < 2:
        return "WHOIS: domini no vàlid."

    tld = parts[-1]
    try:
        iana = whois_query("whois.iana.org", tld)
    except Exception as e:
        return f"WHOIS error (IANA): {e}"

    m = re.search(r"(?i)refer:\s*([^\s]+)", iana) or re.search(r"(?i)whois:\s*([^\s]+)", iana)
    servers_to_try = [m.group(1).strip()] if m else []
    servers_to_try += ["whois.verisign-grs.com", "whois.nic.cat", "whois.pir.org"]

    for srv in servers_to_try:
        try:
            out = whois_query(srv, domain)
            if "Domain Name:" in out or "Registrant" in out:
                return f"WHOIS server: {srv}\n{out}"
        except Exception:
            continue
    return "WHOIS: no s’ha pogut obtenir dades útils."

def resolve_with_dnspython(domain: str):
    res = dns.resolver.Resolver()  # type: ignore
    res.timeout = 3
    res.lifetime = 5
    def q(rr):
        try:
            return [r.to_text() for r in res.resolve(domain, rr)]
        except Exception:
            return []
    return {"A": q("A"), "AAAA": q("AAAA"), "MX": q("MX"), "NS": q("NS"), "TXT": q("TXT")}

def resolve_basic(domain: str):
    out = {"A": [], "AAAA": []}
    try:
        infos = socket.getaddrinfo(domain, None)
        v4 = sorted({i[4][0] for i in infos if i[0] == socket.AF_INET})
        v6 = sorted({i[4][0] for i in infos if i[0] == socket.AF_INET6})
        out["A"] = v4
        out["AAAA"] = v6
    except Exception:
        pass
    return out

def http_get(url: str, timeout=8, headers=None, method="GET"):
    if headers is None:
        headers = {"User-Agent": "PentestLight/1.0"}
    req = Request(url, headers=headers, method=method)
    with urlopen(req, timeout=timeout) as r:
        return r.getcode(), dict(r.getheaders()), r.read()

def check_tcp(host: str, port: int, timeout=2.0) -> bool:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(timeout)
    try:
        s.connect((host, port))
        return True
    except Exception:
        return False
    finally:
        try:
            s.close()
        except Exception:
            pass

def detect_wordpress(html_bytes: bytes, headers: dict):
    txt = html_bytes.decode("utf-8", errors="ignore")
    found_wp = "wp-content/" in txt or "wp-includes/" in txt
    mg = re.search(r'<meta\s+name=["\']generator["\']\s+content=["\']WordPress\s+([^"\']+)["\']', txt, re.I)
    version = mg.group(1).strip() if mg else None
    return found_wp, version

COMMON_SUBS = ["www", "blog", "dev", "api", "stage", "cdn", "mail"]
def resolve_subs(root_domain: str):
    found = []
    for sd in COMMON_SUBS:
        fqdn = f"{sd}.{root_domain}"
        try:
            socket.getaddrinfo(fqdn, None)
            found.append(fqdn)
        except Exception:
            pass
    return found

# ------------------ Port parsing & scanning ------------------
def parse_ports_arg(ports_arg: str):
    if not ports_arg:
        return []
    parts = re.split(r'\s*,\s*', ports_arg.strip())
    ports = set()
    for p in parts:
        if '-' in p:
            try:
                a, b = p.split('-', 1)
                a_i = int(a); b_i = int(b)
                lo, hi = min(a_i, b_i), max(a_i, b_i)
                if 1 <= lo <= 65535 and 1 <= hi <= 65535:
                    for x in range(lo, hi + 1):
                        ports.add(x)
            except Exception:
                continue
        else:
            try:
                pi = int(p)
                if 1 <= pi <= 65535:
                    ports.add(pi)
            except Exception:
                continue
    return sorted(ports)

def scan_port_connect(host: str, port: int, timeout: float = 0.9) -> bool:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(timeout)
    try:
        s.connect((host, port))
        return True
    except Exception:
        return False
    finally:
        try:
            s.close()
        except Exception:
            pass

def scan_ports_concurrent(host: str, ports: list, concurrency: int = 50, timeout: float = 0.9):
    results = {}
    q = Queue()
    for p in ports:
        q.put(p)

    sem = threading.Semaphore(concurrency)
    lock = threading.Lock()

    def worker():
        while True:
            try:
                p = q.get_nowait()
            except Exception:
                break
            with sem:
                ok = scan_port_connect(host, p, timeout=timeout)
                with lock:
                    results[p] = ok
                q.task_done()

    threads = []
    nthreads = min(len(ports), max(4, concurrency))
    for _ in range(nthreads):
        t = threading.Thread(target=worker, daemon=True)
        t.start()
        threads.append(t)

    q.join()
    for t in threads:
        t.join(timeout=0.1)
    return results

# ------------------ Tee (duplica stdout a fitxer i terminal) ------------------
class Tee(io.TextIOBase):
    def __init__(self, *streams):
        self.streams = streams
    def write(self, s):
        for st in self.streams:
            st.write(s)
            try:
                st.flush()
            except Exception:
                pass
        return len(s)
    def flush(self):
        for st in self.streams:
            try:
                st.flush()
            except Exception:
                pass

# ------------------ Authorization helper ------------------
def require_authorization(prompt="Si tens autorització, escriu EXACTAMENT: I_HAVE_PERMISSION"):
    print(prompt)
    ans = input("> ").strip()
    return ans == "I_HAVE_PERMISSION"

# ------------------ CMS detection (multi-platform) ------------------
def detect_cms_all(base_url: str, homepage_body: bytes, headers: dict, active: bool = False, timeout=3):
    txt = homepage_body.decode("utf-8", errors="ignore") if homepage_body else ""
    hdrs_lower = {k.lower(): v for k, v in (headers or {}).items()}

    candidates = {}

    def score(name, reason, weight=1):
        ent = candidates.setdefault(name, {"score": 0, "reasons": []})
        ent["score"] += weight
        ent["reasons"].append(reason)

    # WordPress indicators
    if "wp-content/" in txt or "wp-includes/" in txt:
        score("WordPress", "Found wp-content/wp-includes in HTML", 5)
    if "xmlrpc.php" in txt or "/wp-json/" in txt:
        score("WordPress", "xmlrpc or REST hints in HTML", 3)
    if re.search(r'<meta\s+name=["\']generator["\']\s+content=["\']WordPress', txt, flags=re.I):
        score("WordPress", "meta generator WordPress", 4)

    # Joomla
    if re.search(r'/(templates|media)/[^"\']+', txt, flags=re.I) and "joomla" in txt.lower():
        score("Joomla", "Explicit Joomla string + templates/media", 5)
    if re.search(r'<meta name=["\']generator["\'] content=["\']Joomla', txt, flags=re.I):
        score("Joomla", "meta generator Joomla", 4)
    if "/administrator/" in txt:
        score("Joomla", "/administrator/ found in HTML", 2)

    # Drupal
    if re.search(r'/sites/(default|all)/', txt, flags=re.I):
        score("Drupal", "sites/default or sites/all found", 5)
    if re.search(r'<meta name=["\']Generator["\'] content=["\']Drupal', txt, flags=re.I):
        score("Drupal", "meta generator Drupal", 4)

    # Ghost
    if 'content="Ghost' in txt or '/assets/js/ghost' in txt:
        score("Ghost", "Ghost meta or assets", 6)

    # Shopify
    if re.search(r'cdn\.shopify\.com', txt) or 'shopify' in txt.lower():
        score("Shopify", "cdn.shopify.com or headers/strings", 5)

    # Squarespace / Wix
    if 'squarespace-' in txt or '.squarespace.com' in txt:
        score("Squarespace", "Squarespace assets or strings", 5)
    if 'wix.com' in txt or 'wix-static' in txt or any('x-wix' in k for k in hdrs_lower.keys()):
        score("Wix", "Wix artifacts or headers", 5)

    # TYPO3 / Magento
    if 'typo3' in txt.lower():
        score("TYPO3", "typo3 in HTML", 4)
    if 'mage/checkout' in txt or 'magento' in txt.lower():
        score("Magento", "Magento strings", 5)

    # Header-based hints
    server = hdrs_lower.get("server", "")
    xpb = hdrs_lower.get("x-powered-by", "")
    if "cloudflare" in server:
        score("Cloudflare CDN (frontend)", "Server header contains Cloudflare", 2)
    if "wp.com" in server or "wordpress" in server:
        score("WordPress.com/Automattic", "Server header indicates wordpress.com", 4)
    if "x-powered-by" in hdrs_lower and "php" in xpb.lower():
        score("PHP-based site", "X-Powered-By suggests PHP", 1)

    # Lightweight active checks (only if active=True)
    active_checks = []
    if active:
        probes = {
            "WordPress": ["/wp-login.php", "/xmlrpc.php", "/wp-json/"],
            "Joomla": ["/administrator/"],
            "Drupal": ["/user/login"],
            "Ghost": ["/ghost/"],
            "Shopify": ["/collections/"],
            "Magento": ["/LICENSE.txt", "/magento_version"],
        }
        for cms_name, paths in probes.items():
            for p in paths:
                urlp = base_url.rstrip('/') + p
                try:
                    code, hdrs_p, _ = http_get(urlp, timeout=timeout, method="HEAD")
                    active_checks.append((cms_name, p, code))
                    if 200 <= code < 400:
                        score(cms_name, f"Active probe {p} -> {code}", 6)
                        break
                    elif code == 405:
                        code2, hdrs2, body2 = http_get(urlp, timeout=timeout, method="GET")
                        if 200 <= code2 < 400:
                            score(cms_name, f"Active GET {p} -> {code2}", 6)
                            break
                except Exception:
                    continue

    # Build result list with confidence
    results = []
    for name, info in candidates.items():
        score_val = info["score"]
        if score_val >= 8:
            conf = "high"
        elif score_val >= 4:
            conf = "medium"
        else:
            conf = "low"
        results.append((name, conf, info["reasons"], info["score"]))

    results.sort(key=lambda x: (-x[3], x[1], -len(x[2])))
    return results, active_checks

# ------------------ Main scanning workflow ------------------
def run_scan(url: str, active: bool, save_output=True,
             ports_arg=None, port_concurrency=50, port_timeout=0.9,
             no_save=False, allowed_file=None, export_json=True,
             cms_detect=False, cms_active=False):
    t = normalize_target(url)
    root = t["root"]
    host = t["host"]
    base = f'{t["scheme"]}://{host}'
    timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
    filename = f"{host}_{timestamp}.txt"
    json_filename = f"{host}_{timestamp}.json"

    # Allowed-file checking (if provided)
    if allowed_file:
        try:
            allowed = set(line.strip() for line in open(allowed_file, encoding="utf-8") if line.strip() and not line.strip().startswith("#"))
            if host not in allowed and root not in allowed:
                print(f"{C_RED}[!]{C_END} Target no permitted by allowed-file. Sortint.")
                return
        except Exception as e:
            print(f"{C_RED}[!] Error llegint allowed-file: {e}{C_END}")
            return

    # Prepare output capture: verbose to terminal + file (unless no_save)
    orig_stdout = sys.stdout
    fout = None
    if not no_save:
        fout = open(filename, "w", encoding="utf-8")
        sys.stdout = Tee(orig_stdout, fout)

    # placeholders for summary even if errors happen
    dnsres = {}
    subs = []
    basic_ports = {}
    port_results = {}
    open_ports = []
    who = ""
    found_wp = False
    wp_ver = None
    cms_results = []
    cms_active_checks = []

    try:
        banner()
        print("=" * 60)
        cprint("+", f"Target: {host} (root: {root})")

        print("=" * 60)
        cprint("⚙", "WHOIS (real)")
        who = whois_lookup(root)
        print(who[:3000] + ("\n... (truncat)" if len(who) > 3000 else ""))

        print("=" * 60)
        cprint("⚙", "DNS (real)")
        if HAVE_DNSPY:
            dnsres = resolve_with_dnspython(root)
        else:
            dnsres = resolve_basic(root)
            cprint("!", "DNSpython no disponible: només A/AAAA", C_YELLOW)
        for rr, vals in dnsres.items():
            print(f"{rr} Records:")
            if vals:
                for v in vals:
                    print(f"  - {v}")
            else:
                print("  (cap)")

        print("=" * 60)
        cprint("⚙", "Subdomain check")
        subs = resolve_subs(root)
        if subs:
            for s in subs:
                print(f"  [+] {s}")
        else:
            print("  (cap resolt)")

        print("=" * 60)
        cprint("⚙", "Open TCP ports (22,80,443) - comprobació ràpida")
        basic_ports = {22: check_tcp(host, 22), 80: check_tcp(host, 80), 443: check_tcp(host, 443)}
        for p, ok in basic_ports.items():
            print(f"  {p}/tcp: {'open' if ok else 'closed'}")

        # Extended port scan if requested
        if ports_arg:
            ports_to_scan = parse_ports_arg(ports_arg)
        else:
            # default sensible list (small)
            ports_to_scan = parse_ports_arg("21,22,23,25,53,80,110,139,143,161,389,443,445,587,631,993,995,1433,1521,3306,3389,5432,5900,8080,8443")

        # If user requested many ports, require authorization
        if len(ports_to_scan) > 200:
            if not active:
                print(f"{C_RED}[!] Demanat escaneig de >200 ports però --active no activat. Saltant escaneig ampli.{C_END}")
                ports_to_scan = []
            else:
                print(f"{C_YELLOW}[!] Escaneig ampli de {len(ports_to_scan)} ports sol·licitat. Requereix confirmació.{C_END}")
                if not require_authorization():
                    print("No s'ha confirmat autorització. Cancel·lant escaneig ampli.")
                    ports_to_scan = []

        if ports_to_scan:
            # Ensure active and authorization for any extended scanning
            if not active:
                print(f"{C_YELLOW}[!] Extended port scan requires --active. Saltant.{C_END}")
            else:
                print("=" * 60)
                cprint("⚙", f"Extended port scan ({len(ports_to_scan)} ports) — concurrència {port_concurrency}")
                if not require_authorization("Confirma autorització per escanejar ports: escriu EXACTAMENT I_HAVE_PERMISSION"):
                    print("No s'ha confirmat autorització. Saltant escaneig de ports ampli.")
                else:
                    port_results = scan_ports_concurrent(host, ports_to_scan, concurrency=port_concurrency, timeout=port_timeout)
                    open_ports = sorted([p for p, ok in port_results.items() if ok])
                    if open_ports:
                        print("Ports oberts detectats:")
                        for p in open_ports:
                            print(f"  - {p}/tcp")
                    else:
                        print("No s'han detectat ports oberts en la llista escanejada.")
        else:
            port_results = {}
            open_ports = []

        print("=" * 60)
        cprint("⚙", "robots.txt")
        try:
            code, _, body = http_get(base + "/robots.txt", timeout=6)
            print(f"  GET /robots.txt -> {code}")
            if 200 <= code < 300:
                txt = body.decode("utf-8", errors="ignore")
                preview = "\n".join(txt.splitlines()[:20])
                print(preview)
        except Exception as e:
            print(f"  Error: {e}")

        print("=" * 60)
        cprint("⚙", "Homepage + WordPress heuristics")
        try:
            code, hdrs, body = http_get(base + "/", timeout=8)
            print(f"  GET / -> {code}")
            found_wp, wp_ver = detect_wordpress(body, hdrs)
            print(f"  WordPress detected: {'yes' if found_wp else 'no'}")
            if wp_ver:
                print(f"  Version: {wp_ver}")
            if 'Server' in hdrs:
                print(f"  Server: {hdrs['Server']}")
        except Exception as e:
            print(f"  Error: {e}")
            hdrs = {}
            body = b""
            found_wp = False
            wp_ver = None

        # CMS detection (passive + optional active)
        if cms_detect:
            do_cms_active = False
            if cms_active:
                if not active:
                    print(f"{C_YELLOW}[!] --cms-active requires --active. Skipping active CMS probes.{C_END}")
                else:
                    print(f"{C_YELLOW}[!] CMS active probes requested; will require confirmation.{C_END}")
                    if require_authorization("Confirma autorització per a CMS active probes: escriu EXACTAMENT I_HAVE_PERMISSION"):
                        do_cms_active = True
                    else:
                        print("No s'ha confirmat autorització per CMS active probes. S'executa només detecció passiva.")
            try:
                cms_results, cms_active_checks = detect_cms_all(base, body, hdrs, active=do_cms_active, timeout=3)
                if cms_results:
                    print("\n[CMS detection]")
                    for name, conf, reasons, score in cms_results:
                        print(f"  - {name}  (confidence: {conf}, score: {score})")
                        for r in reasons[:3]:
                            print(f"     • {r}")
                else:
                    print("\n[CMS detection] No strong indicators found.")
                if cms_active_checks:
                    print("\n[CMS active probe log] (cms, path, status):")
                    for item in cms_active_checks:
                        print(f"  {item[0]} {item[1]} -> {item[2]}")
            except Exception as e:
                print(f"[!] Error in CMS detection: {e}")
                cms_results = []
                cms_active_checks = []

        # Active paths if allowed
        if active:
            print("=" * 60)
            cprint("⚙", "Active paths (HEAD/GET no-intrusiu)", C_YELLOW)
            if not require_authorization():
                print("No s'ha confirmat autorització per a checks actius. Saltant.")
            else:
                for p in ["/wp-login.php", "/admin/", "/login", "/.well-known/security.txt"]:
                    try:
                        code, _, _ = http_get(base + p, timeout=5, method="HEAD")
                        print(f"  {p} -> {code}")
                    except Exception as e:
                        print(f"  {p} -> error: {e}")

        # Build JSON summary if requested
        summary = {
            "target": host,
            "root": root,
            "timestamp": timestamp,
            "whois_snippet": who[:2000],
            "dns": dnsres,
            "subs": subs,
            "basic_ports": basic_ports,
            "extended_open_ports": open_ports if ports_to_scan else [],
            "wordpress": {"detected": bool(found_wp), "version": wp_ver if 'wp_ver' in locals() else None},
            "cms": [{"name": n, "confidence": c, "reasons": r, "score": s} for (n, c, r, s) in (cms_results or [])]
        }

        # save JSON if required
        if export_json and not no_save:
            try:
                with open(json_filename, "w", encoding="utf-8") as jf:
                    json.dump(summary, jf, indent=2, ensure_ascii=False)
                print(f"\nJSON results saved to: {json_filename}")
            except Exception as e:
                print(f"Error guardant JSON: {e}")

    finally:
        # restore stdout and close file
        if not no_save and fout:
            sys.stdout = orig_stdout
            try:
                fout.close()
            except Exception:
                pass
            print(f"\n{C_GREEN}[✓]{C_END} Resultats desats a: {filename}\n")
        else:
            # if no_save, ensure stdout unchanged
            if no_save:
                sys.stdout = orig_stdout

def main():
    parser = argparse.ArgumentParser(description="Pentest Light amb exportació a TXT i escaneig de ports")
    parser.add_argument("-u", "--url", required=True, help="Target URL o domini (ex: https://exemple.cat)")
    parser.add_argument("--active", action="store_true", help="Activa comprovacions de rutes web (lleus) i permet escaneig ampli amb confirmació")
    parser.add_argument("--ports", type=str, default=None, help="Llista de ports o rangs, p.ex. '22,80,443,8000-8100'.")
    parser.add_argument("--port-concurrency", type=int, default=50, help="Nombre màxim de connexions paral·leles per l'scan de ports.")
    parser.add_argument("--port-timeout", type=float, default=0.9, help="Timeout (segons) per a cada connexió TCP a un port.")
    parser.add_argument("--no-save", action="store_true", help="No guardar fitxer de resultats (només verbose al terminal).")
    parser.add_argument("--allowed-file", type=str, default=None, help="Fitxer amb llista de targets permesos (un per línia).")
    parser.add_argument("--export-json", action="store_true", help="Exportar resum en JSON juntament amb el TXT.")
    parser.add_argument("--cms-detect", action="store_true", help="Fer detecció de CMS passiva (HTML + headers).")
    parser.add_argument("--cms-active", action="store_true", help="Fer probes lleus per a detecció de CMS (requereix --active i confirmació).")
    args = parser.parse_args()

    run_scan(args.url, active=args.active, save_output=not args.no_save,
             ports_arg=args.ports, port_concurrency=args.port_concurrency,
             port_timeout=args.port_timeout, no_save=args.no_save,
             allowed_file=args.allowed_file, export_json=args.export_json,
             cms_detect=args.cms_detect, cms_active=args.cms_active)

if __name__ == "__main__":
    main()
