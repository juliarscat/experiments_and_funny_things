#!/usr/bin/env python3
"""
Pentest Light — Recon prudent amb logging (verbose) i escaneig de ports connect (concurrent).
Ús responsable: només executar contra targets amb autorització.
"""
import argparse
import socket
import sys
import io
import re
import json
import threading
from queue import Queue
from datetime import datetime
from urllib.parse import urlparse
from urllib.request import Request, urlopen
from urllib.error import URLError, HTTPError

# Optional dnspython
try:
    import dns.resolver  # type: ignore
    HAVE_DNSPY = True
except Exception:
    HAVE_DNSPY = False

C_GREEN = '\033[92m'
C_YELLOW = '\033[93m'
C_RED = '\033[91m'
C_END = '\033[0m'

def cprint(tag, msg, color=C_GREEN):
    print(f"{color}[{tag}]{C_END} {msg}")

def banner():
    print(f"{C_GREEN}[*]{C_END} Pentest Light — Real-world Passive Recon (safe)")

def normalize_target(raw_url: str):
    if not re.match(r'^[a-zA-Z][a-zA-Z0-9+.-]*://', raw_url):
        raw_url = 'http://' + raw_url
    p = urlparse(raw_url)
    host = p.hostname or raw_url
    scheme = p.scheme or 'http'
    port = p.port
    if port is None:
        port = 443 if scheme == 'https' else 80
    root = host[4:] if host.startswith('www.') else host
    return {"raw": raw_url.rstrip('/'), "scheme": scheme, "host": host, "port": port, "root": root}

def whois_query(server: str, query: str, timeout=10) -> str:
    data = b""
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(timeout)
    try:
        s.connect((server, 43))
        s.sendall((query + "\r\n").encode("utf-8", errors="ignore"))
        while True:
            chunk = s.recv(4096)
            if not chunk:
                break
            data += chunk
    finally:
        s.close()
    return data.decode("utf-8", errors="ignore")

def whois_lookup(domain: str) -> str:
    parts = domain.strip().split(".")
    if len(parts) < 2:
        return "WHOIS: domini no vàlid."

    tld = parts[-1]
    try:
        iana = whois_query("whois.iana.org", tld)
    except Exception as e:
        return f"WHOIS error (IANA): {e}"

    m = re.search(r"(?i)refer:\s*([^\s]+)", iana) or re.search(r"(?i)whois:\s*([^\s]+)", iana)
    servers_to_try = [m.group(1).strip()] if m else []
    servers_to_try += ["whois.verisign-grs.com", "whois.nic.cat", "whois.pir.org"]

    for srv in servers_to_try:
        try:
            out = whois_query(srv, domain)
            if "Domain Name:" in out or "Registrant" in out:
                return f"WHOIS server: {srv}\n{out}"
        except Exception:
            continue
    return "WHOIS: no s’ha pogut obtenir dades útils."

def resolve_with_dnspython(domain: str):
    res = dns.resolver.Resolver()  # type: ignore
    res.timeout = 3
    res.lifetime = 5
    def q(rr):
        try:
            return [r.to_text() for r in res.resolve(domain, rr)]
        except Exception:
            return []
    return {"A": q("A"), "AAAA": q("AAAA"), "MX": q("MX"), "NS": q("NS"), "TXT": q("TXT")}

def resolve_basic(domain: str):
    out = {"A": [], "AAAA": []}
    try:
        infos = socket.getaddrinfo(domain, None)
        v4 = sorted({i[4][0] for i in infos if i[0] == socket.AF_INET})
        v6 = sorted({i[4][0] for i in infos if i[0] == socket.AF_INET6})
        out["A"] = v4
        out["AAAA"] = v6
    except Exception:
        pass
    return out

def http_get(url: str, timeout=8, headers=None, method="GET"):
    if headers is None:
        headers = {"User-Agent": "PentestLight/1.0"}
    req = Request(url, headers=headers, method=method)
    with urlopen(req, timeout=timeout) as r:
        return r.getcode(), dict(r.getheaders()), r.read()

def check_tcp(host: str, port: int, timeout=2.0) -> bool:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(timeout)
    try:
        s.connect((host, port))
        return True
    except Exception:
        return False
    finally:
        try:
            s.close()
        except Exception:
            pass

def detect_wordpress(html_bytes: bytes, headers: dict):
    txt = html_bytes.decode("utf-8", errors="ignore")
    found_wp = "wp-content/" in txt or "wp-includes/" in txt
    mg = re.search(r'<meta\s+name=["\']generator["\']\s+content=["\']WordPress\s+([^"\']+)["\']', txt, re.I)
    version = mg.group(1).strip() if mg else None
    return found_wp, version

COMMON_SUBS = ["www", "blog", "dev", "api", "stage", "cdn", "mail"]
def resolve_subs(root_domain: str):
    found = []
    for sd in COMMON_SUBS:
        fqdn = f"{sd}.{root_domain}"
        try:
            socket.getaddrinfo(fqdn, None)
            found.append(fqdn)
        except Exception:
            pass
    return found

# ------------------ Port parsing & scanning ------------------
def parse_ports_arg(ports_arg: str):
    if not ports_arg:
        return []
    parts = re.split(r'\s*,\s*', ports_arg.strip())
    ports = set()
    for p in parts:
        if '-' in p:
            try:
                a, b = p.split('-', 1)
                a_i = int(a); b_i = int(b)
                lo, hi = min(a_i, b_i), max(a_i, b_i)
                if 1 <= lo <= 65535 and 1 <= hi <= 65535:
                    for x in range(lo, hi + 1):
                        ports.add(x)
            except Exception:
                continue
        else:
            try:
                pi = int(p)
                if 1 <= pi <= 65535:
                    ports.add(pi)
            except Exception:
                continue
    return sorted(ports)

def scan_port_connect(host: str, port: int, timeout: float = 0.9) -> bool:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(timeout)
    try:
        s.connect((host, port))
        return True
    except Exception:
        return False
    finally:
        try:
            s.close()
        except Exception:
            pass

def scan_ports_concurrent(host: str, ports: list, concurrency: int = 50, timeout: float = 0.9):
    results = {}
    q = Queue()
    for p in ports:
        q.put(p)

    sem = threading.Semaphore(concurrency)
    lock = threading.Lock()

    def worker():
        while True:
            try:
                p = q.get_nowait()
            except Exception:
                break
            with sem:
                ok = scan_port_connect(host, p, timeout=timeout)
                with lock:
                    results[p] = ok
                q.task_done()

    threads = []
    nthreads = min(len(ports), max(4, concurrency))
    for _ in range(nthreads):
        t = threading.Thread(target=worker, daemon=True)
        t.start()
        threads.append(t)

    q.join()
    for t in threads:
        t.join(timeout=0.1)
    return results

# ------------------ Tee (duplica stdout a fitxer i terminal) ------------------
class Tee(io.TextIOBase):
    def __init__(self, *streams):
        self.streams = streams
    def write(self, s):
        for st in self.streams:
            st.write(s)
            try:
                st.flush()
            except Exception:
                pass
        return len(s)
    def flush(self):
        for st in self.streams:
            try:
                st.flush()
            except Exception:
                pass

# ------------------ Authorization helper ------------------
def require_authorization(prompt="Si tens autorització, escriu EXACTAMENT: I_HAVE_PERMISSION"):
    print(prompt)
    ans = input("> ").strip()
    return ans == "I_HAVE_PERMISSION"

# ------------------ Main scanning workflow ------------------
def run_scan(url: str, active: bool, save_output=True,
             ports_arg=None, port_concurrency=50, port_timeout=0.9,
             no_save=False, allowed_file=None, export_json=True):
    t = normalize_target(url)
    root = t["root"]
    host = t["host"]
    base = f'{t["scheme"]}://{host}'
    timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
    filename = f"{host}_{timestamp}.txt"
    json_filename = f"{host}_{timestamp}.json"

    # Allowed-file checking (if provided)
    if allowed_file:
        try:
            allowed = set(line.strip() for line in open(allowed_file, encoding="utf-8") if line.strip())
            if host not in allowed and root not in allowed:
                print(f"{C_RED}[!]{C_END} Target no permitted by allowed-file. Sortint.")
                return
        except Exception as e:
            print(f"{C_RED}[!] Error llegint allowed-file: {e}{C_END}")
            return

    # Prepare output capture: verbose to terminal + file (unless no_save)
    orig_stdout = sys.stdout
    fout = None
    if not no_save:
        fout = open(filename, "w", encoding="utf-8")
        sys.stdout = Tee(orig_stdout, fout)

    try:
        banner()
        print("=" * 60)
        cprint("+", f"Target: {host} (root: {root})")

        print("=" * 60)
        cprint("⚙", "WHOIS (real)")
        who = whois_lookup(root)
        print(who[:3000] + ("\n... (truncat)" if len(who) > 3000 else ""))

        print("=" * 60)
        cprint("⚙", "DNS (real)")
        if HAVE_DNSPY:
            dnsres = resolve_with_dnspython(root)
        else:
            dnsres = resolve_basic(root)
            cprint("!", "DNSpython no disponible: només A/AAAA", C_YELLOW)
        for rr, vals in dnsres.items():
            print(f"{rr} Records:")
            if vals:
                for v in vals:
                    print(f"  - {v}")
            else:
                print("  (cap)")

        print("=" * 60)
        cprint("⚙", "Subdomain check")
        subs = resolve_subs(root)
        if subs:
            for s in subs:
                print(f"  [+] {s}")
        else:
            print("  (cap resolt)")

        print("=" * 60)
        cprint("⚙", "Open TCP ports (22,80,443) - comprobació ràpida")
        basic_ports = {22: check_tcp(host, 22), 80: check_tcp(host, 80), 443: check_tcp(host, 443)}
        for p, ok in basic_ports.items():
            print(f"  {p}/tcp: {'open' if ok else 'closed'}")

        # Extended port scan if requested
        if ports_arg:
            ports_to_scan = parse_ports_arg(ports_arg)
        else:
            # default sensible list (small)
            ports_to_scan = parse_ports_arg("21,22,23,25,53,80,110,139,143,161,389,443,445,587,631,993,995,1433,1521,3306,3389,5432,5900,8080,8443")

        # If user requested many ports, require authorization
        if len(ports_to_scan) > 200:
            if not active:
                print(f"{C_RED}[!] Demanat escaneig de >200 ports però --active no activat. Saltant escaneig ampli.{C_END}")
                ports_to_scan = []
            else:
                print(f"{C_YELLOW}[!] Escaneig ampli de {len(ports_to_scan)} ports sol·licitat. Requereix confirmació.{C_END}")
                if not require_authorization():
                    print("No s'ha confirmat autorització. Cancel·lant escaneig ampli.")
                    ports_to_scan = []

        if ports_to_scan:
            # Ensure active and authorization for any extended scanning
            if not active:
                print(f"{C_YELLOW}[!] Extended port scan requires --active. Saltant.{C_END}")
            else:
                print("=" * 60)
                cprint("⚙", f"Extended port scan ({len(ports_to_scan)} ports) — concurrència {port_concurrency}")
                if not require_authorization("Confirma autorització per escanejar ports: escriu EXACTAMENT I_HAVE_PERMISSION"):
                    print("No s'ha confirmat autorització. Saltant escaneig de ports ampli.")
                else:
                    port_results = scan_ports_concurrent(host, ports_to_scan, concurrency=port_concurrency, timeout=port_timeout)
                    open_ports = sorted([p for p, ok in port_results.items() if ok])
                    if open_ports:
                        print("Ports oberts detectats:")
                        for p in open_ports:
                            print(f"  - {p}/tcp")
                    else:
                        print("No s'han detectat ports oberts en la llista escanejada.")
        else:
            port_results = {}
            open_ports = []

        print("=" * 60)
        cprint("⚙", "robots.txt")
        try:
            code, _, body = http_get(base + "/robots.txt", timeout=6)
            print(f"  GET /robots.txt -> {code}")
            if 200 <= code < 300:
                txt = body.decode("utf-8", errors="ignore")
                preview = "\n".join(txt.splitlines()[:20])
                print(preview)
        except Exception as e:
            print(f"  Error: {e}")

        print("=" * 60)
        cprint("⚙", "Homepage + WordPress heuristics")
        try:
            code, hdrs, body = http_get(base + "/", timeout=8)
            print(f"  GET / -> {code}")
            found_wp, wp_ver = detect_wordpress(body, hdrs)
            print(f"  WordPress detected: {'yes' if found_wp else 'no'}")
            if wp_ver:
                print(f"  Version: {wp_ver}")
            if 'Server' in hdrs:
                print(f"  Server: {hdrs['Server']}")
        except Exception as e:
            print(f"  Error: {e}")

        # Active paths if allowed
        if active:
            print("=" * 60)
            cprint("⚙", "Active paths (HEAD/GET no-intrusiu)", C_YELLOW)
            if not require_authorization():
                print("No s'ha confirmat autorització per a checks actius. Saltant.")
            else:
                for p in ["/wp-login.php", "/admin/", "/login", "/.well-known/security.txt"]:
                    try:
                        code, _, _ = http_get(base + p, timeout=5, method="HEAD")
                        print(f"  {p} -> {code}")
                    except Exception as e:
                        print(f"  {p} -> error: {e}")

        # Build JSON summary if requested
        summary = {
            "target": host,
            "root": root,
            "timestamp": timestamp,
            "whois_snippet": who[:2000],
            "dns": dnsres,
            "subs": subs,
            "basic_ports": basic_ports,
            "extended_open_ports": open_ports if ports_to_scan else [],
            "wordpress": {"detected": bool(found_wp), "version": wp_ver if 'wp_ver' in locals() else None}
        }

        # save JSON if required
        if export_json and not no_save:
            try:
                with open(json_filename, "w", encoding="utf-8") as jf:
                    json.dump(summary, jf, indent=2, ensure_ascii=False)
                print(f"\nJSON results saved to: {json_filename}")
            except Exception as e:
                print(f"Error guardant JSON: {e}")

    finally:
        # restore stdout and close file
        if not no_save and fout:
            sys.stdout = orig_stdout
            try:
                fout.close()
            except Exception:
                pass
            print(f"\n{C_GREEN}[✓]{C_END} Resultats desats a: {filename}\n")
        else:
            # if no_save, ensure stdout unchanged
            if no_save:
                sys.stdout = orig_stdout

def main():
    parser = argparse.ArgumentParser(description="Pentest Light amb exportació a TXT i escaneig de ports")
    parser.add_argument("-u", "--url", required=True, help="Target URL o domini (ex: https://exemple.cat)")
    parser.add_argument("--active", action="store_true", help="Activa comprovacions de rutes web (lleus) i permet escaneig ampli amb confirmació")
    parser.add_argument("--ports", type=str, default=None, help="Llista de ports o rangs, p.ex. '22,80,443,8000-8100'.")
    parser.add_argument("--port-concurrency", type=int, default=50, help="Nombre màxim de connexions paral·leles per l'scan de ports.")
    parser.add_argument("--port-timeout", type=float, default=0.9, help="Timeout (segons) per a cada connexió TCP a un port.")
    parser.add_argument("--no-save", action="store_true", help="No guardar fitxer de resultats (només verbose al terminal).")
    parser.add_argument("--allowed-file", type=str, default=None, help="Fitxer amb llista de targets permesos (un per línia).")
    parser.add_argument("--export-json", action="store_true", help="Exportar resum en JSON juntament amb el TXT.")
    args = parser.parse_args()

    run_scan(args.url, active=args.active, save_output=not args.no_save,
             ports_arg=args.ports, port_concurrency=args.port_concurrency,
             port_timeout=args.port_timeout, no_save=args.no_save,
             allowed_file=args.allowed_file, export_json=args.export_json)

if __name__ == "__main__":
    main()

